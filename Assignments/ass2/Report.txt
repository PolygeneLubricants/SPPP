NOTE:
All run times are calculated on the following processor:
Intel Core i5-2450M CPU @ 2.50GHz (4 CPUs)

2.1.1
Yes

2.1.2
Yes

2.1.3
No, you can not rely on the termination of the program. You will need a memory barrier before the reading the MutableIntegers value and after the writing to the MutableIntergers value. synchronized applies a memory barrier before and after the synchronised block (the set and get methods of MutableInteger in the given example).

2.1.4
Using volatile is sufficient, as it applies a memory barrier before read operations and after write operations. And, the value we write is not based on the original value, so there is no need to make any operation atomic.

2.2.1


2.2.2
Faster

2.2.3
No, count = count + 1 is not atomic.

2.2.4
No it does not matter.
The synchronized method LongCounter.increment has ensured that the correct value for LongCounter.count is always in memory. LongCounter.get is called once on the main thread and only after all other threads has terminated, plus LonngCounter.increment has never been called on the main thread thus LongCounter.count has not been cached by the main thread and is read from memory.

2.3.1
$ time java TestCountFactors
Total number of factors is  18703729

real    0m8.676s
user    0m0.015s
sys     0m0.000s
2.3.2

2.3.3

2.3.4

2.3.5

2.4.1

2.4.2
